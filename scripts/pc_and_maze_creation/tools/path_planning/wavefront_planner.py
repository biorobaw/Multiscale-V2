import os, sys, time
from shapely.geometry import Point, LineString
import pandas as pd
from multiprocessing import Pool
import numpy as np
import time

# This file divides space in a grid, and for each cell it approximates the distance to the closest subgoal (obstacle corner) - feeders are ignored


sys.path.append('../utils')
import MazeParser
from data.Wall import PickableWall as Wall
from data.Feeder import PickableFeeder as Feeder
from data.StartPos import PickableStartPos as StartPos


pool = None







def get_grid_and_coordinates(walls, precision):
    min_x = np.min([walls.x1.min(), walls.x2.min()]) - precision/2
    max_x = np.max([walls.x1.max(), walls.x2.max()]) + precision/2
    min_y = np.min([walls.y1.min(), walls.y2.min()]) - precision/2
    max_y = np.max([walls.y1.max(), walls.y2.max()]) + precision/2

    num_x = int(np.ceil((max_x - min_x)/precision))
    num_y = int(np.ceil((max_y - min_y)/precision))
    

    return min_x, num_x, min_y, num_y


def get_id(x, y, min_x, min_y, precision):
    row = int(np.floor( (y - min_y) / precision ))
    col = int(np.floor( (x - min_x) / precision ))
    return row, col

def get_coordinates(i,j, min_x, min_y, precision):
    x = min_x + (j+0.5)*precision
    y = min_y + (i+0.5)*precision
    return x,y

def get_id_from_dim(x, y, dimensions):
    min_x, num_x, min_y, num_y, precision = dimensions

    row = int(np.floor( (y - min_y) / precision ))
    col = int(np.floor( (x - min_x) / precision ))
    return row, col

def get_coordinates_from_dim(i,j, dimensions):
    min_x, num_x, min_y, num_y, precision = dimensions
    x = min_x + (j+0.5)*precision
    y = min_y + (i+0.5)*precision
    return x,y

def point_in_wall(point, wall):
    return point.distance(wall) < 0.005 # at most 5mm away from wall


def wall_to_line_string(w):
    p1 = Point(w.x1, w.y1)
    p2 = Point(w.x2, w.y2)
    return LineString([p1, p2])

        

neighbors = [(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)]
def get_segment_indeces(wall, min_x, min_y, precision, num_x, num_y):
    # FIND ALL INDICES OF THE  WALL IN THE MAP
    (x,y) = wall.coords[0]
    id0 = get_id(x, y, min_x, min_y, precision)
    indices = set({id0})
    process_queue = [id0]

    # repeat until no more elements need to be processed
    while len(process_queue) > 0:
        (i0,j0) = process_queue.pop()

        # check all neighbors
        for (di, dj) in neighbors:
            i = i0 + di
            j = j0 + dj

            # if not valid or already processed, skip cell
            if i < 0 or j < 0 or i >= num_y or j >= num_x or (i,j) in indices:
                continue

            # get cell center and check if lays within wall
            point = Point(get_coordinates(i,j, min_x, min_y, precision))
            if point_in_wall(point, wall):
                indices.add((i,j))
                process_queue.append((i,j))
    return indices


def get_goal_indeces(gx, gy, min_x, min_y, precision, num_x, num_y, max_distance, occupancy_grid, possible_walls):
    # GET ALL INDICES THAT ARE CONSIDERED PART OF THE GOAL (TAKE OBSTACLES INTO ACCOUNT)
    origin = Point(gx,gy)
    (i0,j0) = get_id(gx, gy, min_x, min_y, precision)
    indices = {(i0,j0)}
    checked = {(i0,j0)}

    walls_goal = possible_walls[i0][j0]

    process_queue = [(i0,j0)]

    # repeat until no more elements need to be processed
    while len(process_queue) > 0:
        (i0,j0) = process_queue.pop()

        # check all neighbors
        for (di, dj) in neighbors:
            i = i0 + di
            j = j0 + dj

            # if not valid or already processed or it is in a wall, skip cell
            if i < 0 or j < 0 or i >= num_y or j >= num_x or (i,j) in checked:
                continue
            checked.add((i,j))

            # check segment does not intersect with obstacles and destination is not in occupancy grid
            x, y = get_coordinates(i,j, min_x, min_y, precision)
            if (i, j) in occupancy_grid or not segment_in_freespace(gx,gy,x,y,walls_goal):
                continue

            # make sure point is within feeding distance
            point = Point(x,y)
            if origin.distance(point) >= max_distance:
                continue

            indices.add((i,j))
            process_queue.append((i,j))
    return indices


def segment_in_freespace(x1, y1, x2, y2, walls):
    # Determines if the path generated by an action is in open space
    segment = LineString([Point(x1,y1), Point(x2, y2)])
    for w in walls:
        if segment.distance(w) < 0.001:
            return False
    return True

def possible_collisions(walls, min_x, min_y, precision, num_x, num_y, step):
    # find all positions that might collide with a wall
    possible_walls = [[[] for i in range(num_x)] for i in range(num_y) ]

    for w_id, wall in zip( range(len(walls)), walls):
        (x,y) = wall.coords[0]
        i0,j0 = get_id(x, y, min_x, min_y, precision)
        checked = {(i0,j0)}
        added   = {(i0,j0)}

        # repeat until no more elements need to be processed
        process_queue = [(i0,j0)]
        while len(process_queue) > 0:
            (i0,j0) = process_queue.pop()

            # check all neighbors
            for (di, dj) in neighbors:
                i = i0 + di
                j = j0 + dj

                # if not valid or already processed, skip cell
                if i < 0 or j < 0 or i >= num_y or j >= num_x or (i,j) in checked:
                    continue
                checked.add((i,j))

                # get cell center and check if lays within wall
                point = Point(get_coordinates(i,j, min_x, min_y, precision))
                if point.distance(wall) <= step + precision:
                    added.add((i,j))
                    process_queue.append((i,j))
        for (i,j) in added:
            possible_walls[i][j].append(wall)
    return possible_walls


def wave_front_planner(walls, feeders):
    print('running wave front planner')
    precision = 0.005
    num_actions = 8
    step = 0.08
    affordance = 0.1
    feeding_distance = 0.1
    d_theta = 2*np.pi / num_actions
    actions = [ (step*np.cos(i*d_theta), step*np.sin(i*d_theta)) for i in range(num_actions)  ]
    affordances = [ (affordance*np.cos(i*d_theta), affordance*np.sin(i*d_theta)) for i in range(num_actions)  ]
    halfp = precision/2
    
    
    # divide maze into a grid:
    min_x, num_x, min_y, num_y = get_grid_and_coordinates(walls, precision = precision) 

    # generate wall occupancy grid
    walls = [ wall_to_line_string(w) for id, w in walls.iterrows() ] # Convert to line strings
    occupancy_grid = set()
    for w in walls:
        occupancy_grid = occupancy_grid.union(get_segment_indeces(w, min_x, min_y, precision, num_x, num_y))
    # for each position, all walls within a given distance (chose affordance + error as it is the largest value)
    possible_walls = possible_collisions(walls, min_x, min_y, precision, num_x, num_y, affordance+0.01)

    # get cell ids of goals
    goal_indices = set()
    for f_id, f in feeders.iterrows():
        goal_indices = goal_indices.union( get_goal_indeces(f.x, f.y, min_x, min_y, precision, num_x, num_y, feeding_distance, occupancy_grid, possible_walls)  )


    # get dimensions of grid and find table of distances and previous ids (use np.array for easily storing results as bins)
    dimensions = np.array([ min_x, num_x, min_y, num_y, precision], np.float64  )
    distances = np.zeros((num_y, num_x)) + 10000 # init to infinity
    previous_point = [[(i,j) for j in range(num_x)] for i in range(num_y)] # init to self

    next_distance = 0
    for (i,j) in goal_indices:
        distances[i, j] = next_distance

    to_process = goal_indices
    remaining = num_x*num_y - len(occupancy_grid)
    time0 = time.time()
    average_time = 1
    while len(to_process)>0:
        processing = to_process
        next_distance += 1
        to_process = set()

        # process cells in buffer
        for (i1,j1) in processing:
            remaining-=1
            if remaining % 10000 == 0:
                stamp = time.time()
                delta = stamp - time0
                average_time = 0.8*average_time + 0.2*delta
                print('remaining cells', remaining, 'remaining seconds', remaining / 10000 * average_time)
                time0 = stamp

            walls_ij = possible_walls[i1][j1]
            x1, y1 = get_coordinates(i1,j1, min_x, min_y, precision)

            # process all neighbors
            for (dx,dy), (dx_aff, dy_aff) in zip(actions,affordances):
                x = x1 + dx
                y = y1 + dy
                i,j = get_id(x,y,min_x, min_y, precision)
                # check if valid cell:
                if i < 0 or i >= num_y or j < 0 or j >= num_x:
                    continue

                # check if already processed or if cant reach position:
                # x_aff, y_aff = x+dx_aff, y+dy_aff # this is not useful as we are moving the other way around
                # we should instead modify previous point, but too many details, we will instead use an approximation
                if next_distance >= distances[i,j] or not segment_in_freespace(x1,y1,x,y, walls_ij):
                    continue
                
                distances[i,j] = next_distance
                previous_point[i][j] = (i1,j1)
                if (i,j) not in occupancy_grid: # do not process neighbors if the cell is a wall
                    to_process.add((i,j))
                    

    print('Planner done!')
    return distances, previous_point, dimensions


def wave_front_planner_from_pickles(wall_pickles, feeder_pickles):
    walls = pd.DataFrame(columns=['x1','y1','x2','y2'],  data=[ [w.x1(), w.y1(), w.x2(), w.y2()] for w in wall_pickles])
    feeders = pd.DataFrame(columns=['x','y'],  data=[ [f.x(), f.y()] for f in feeder_pickles])
    return wave_front_planner(walls, feeders)

def wave_front_planner_from_file(folder, maze_file):
    print('Starting wavefront planner in ', maze_file)
    full_path = os.path.join(folder, maze_file)
    walls, feeders, start_positions = MazeParser.parse_maze(full_path)
    distances, previous_point, dimensions = wave_front_planner(walls, feeders)
    min_x, num_x, min_y, num_y, precision = dimensions


    save_name = full_path.replace('.xml', '_optimal_paths.bin')
    print('Saving ', save_name)
    linear_ids = [ [ i*num_x + j for (i,j) in row ] for row in previous_point ]
    with open(save_name,'bw') as f:
        # print(dimensions.dtype, distances.dtype)
        dimensions.astype('float32').tofile(f)
        distances.astype('float32').tofile(f)
        np.array(linear_ids, dtype=np.float32).tofile(f)
    return ''



def get_path(x, y, distances, previous_point, dimensions):
    i,j = get_id_from_dim(x,y,dimensions)
    path = [[x,y]]
    while (i,j) != previous_point[i][j]:
        i,j = previous_point[i][j]
        path.append(get_coordinates_from_dim(i,j, dimensions))
    print(path)
    return path



def finished_all_mazes(results):
    global pool
    print('finished executing all wavefront planners!')
    pool.close()
    pool = None
    errors = [r for r in results if r!='']
    if(len(errors)>0):
        print('Error with files: {errors}')
    else:
        print('No errors!')


def wave_front_planner_folder(folder):
    debug = False
    if debug:
        # wave_front_planner_from_file('tools/samples', 'M304.xml')
        wave_front_planner_from_file('../../experiments/mazes/obstacles/', 'M600.xml')
        print('done')
    else:
        global pool, start_time
        if(pool is not None):
            print("PROCESS POOL ALREADY OPEN")
            return

        # results = []
        args = [(folder, filename) for filename in os.listdir(folder) if filename.endswith(".xml") ]

        print()
        pool = Pool(12)
        start_time = time.time()
        pool.starmap_async(wave_front_planner_from_file, args, callback=finished_all_mazes)

